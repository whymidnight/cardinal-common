{"version":3,"file":"accounts.js","sourceRoot":"","sources":["../../src/accounts.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Idl } from \"@project-serum/anchor\";\nimport { BorshAccountsCoder, utils } from \"@project-serum/anchor\";\nimport type {\n  AllAccountsMap,\n  IdlTypes,\n  TypeDef,\n} from \"@project-serum/anchor/dist/cjs/program/namespace/types\";\nimport type {\n  AccountInfo,\n  Commitment,\n  Connection,\n  GetAccountInfoConfig,\n  GetMultipleAccountsConfig,\n  GetProgramAccountsConfig,\n  PublicKey,\n} from \"@solana/web3.js\";\n\nexport type ParsedIdlAccountData<\n  T extends keyof AllAccountsMap<IDL>,\n  IDL extends Idl\n> = TypeDef<AllAccountsMap<IDL>[T], IdlTypes<IDL>>;\n\nexport type ParsedIdlAccount<IDL extends Idl> = {\n  [T in keyof AllAccountsMap<IDL>]: {\n    type: T;\n    parsed: ParsedIdlAccountData<T, IDL>;\n  };\n};\n\nexport type IdlAccountInfo<\n  T extends keyof AllAccountsMap<IDL>,\n  IDL extends Idl\n> = AccountInfo<Buffer> & ParsedIdlAccount<IDL>[T];\n\nexport type IdlAccountData<\n  T extends keyof AllAccountsMap<IDL>,\n  IDL extends Idl\n> = {\n  pubkey: PublicKey;\n} & IdlAccountInfo<T, IDL>;\n\nexport type NullableIdlAccountInfo<\n  T extends keyof AllAccountsMap<IDL>,\n  IDL extends Idl\n> =\n  | IdlAccountInfo<T, IDL>\n  | (AccountInfo<Buffer> & {\n      type: \"unknown\";\n      parsed: null;\n    });\n\nexport type NullableIdlAccountData<\n  T extends keyof AllAccountsMap<IDL>,\n  IDL extends Idl\n> = {\n  pubkey: PublicKey;\n} & NullableIdlAccountInfo<T, IDL>;\n\n/**\n * Fetch an account with idl types\n * @param connection\n * @param pubkey\n * @param accountType\n * @param config\n * @returns\n */\nexport const fetchIdlAccount = async <\n  T extends keyof AllAccountsMap<IDL>,\n  IDL extends Idl\n>(\n  connection: Connection,\n  pubkey: PublicKey,\n  accountType: T,\n  idl: Idl,\n  config?: GetAccountInfoConfig\n) => {\n  const account = await fetchIdlAccountNullable<T, IDL>(\n    connection,\n    pubkey,\n    accountType,\n    idl,\n    config\n  );\n  if (!account) throw \"Account info not found\";\n  return account;\n};\n\n/**\n * Fetch a possibly null account with idl types of a specific type\n * @param connection\n * @param pubkey\n * @param accountType\n * @param config\n * @param idl\n * @returns\n */\nexport const fetchIdlAccountNullable = async <\n  T extends keyof AllAccountsMap<IDL>,\n  IDL extends Idl\n>(\n  connection: Connection,\n  pubkey: PublicKey,\n  accountType: T,\n  idl: Idl,\n  config?: GetAccountInfoConfig\n) => {\n  const accountInfo = await connection.getAccountInfo(pubkey, config);\n  if (!accountInfo) return null;\n  try {\n    const parsed: TypeDef<\n      AllAccountsMap<IDL>[T],\n      IdlTypes<IDL>\n    > = new BorshAccountsCoder(idl).decode(accountType, accountInfo.data);\n    return {\n      ...accountInfo,\n      pubkey,\n      parsed,\n      type: accountType,\n    };\n  } catch (e) {\n    return null;\n  }\n};\n\n/**\n * Decode an account with idl types of a specific type\n * @param accountInfo\n * @param accountType\n * @param idl\n * @returns\n */\nexport const decodeIdlAccount = <\n  T extends keyof AllAccountsMap<IDL>,\n  IDL extends Idl\n>(\n  accountInfo: AccountInfo<Buffer>,\n  accountType: T,\n  idl: Idl\n) => {\n  const parsed: TypeDef<\n    AllAccountsMap<IDL>[T],\n    IdlTypes<IDL>\n  > = new BorshAccountsCoder(idl).decode(accountType, accountInfo.data);\n  return {\n    ...accountInfo,\n    type: accountType,\n    parsed,\n  };\n};\n\n/**\n * Try to decode an account with idl types of specific type\n * @param accountInfo\n * @param accountType\n * @param idl\n * @returns\n */\nexport const tryDecodeIdlAccount = <\n  T extends keyof AllAccountsMap<IDL>,\n  IDL extends Idl\n>(\n  accountInfo: AccountInfo<Buffer>,\n  accountType: T,\n  idl: Idl\n) => {\n  try {\n    return decodeIdlAccount<T, IDL>(accountInfo, accountType, idl);\n  } catch (e) {\n    return {\n      ...accountInfo,\n      type: \"unknown\",\n      parsed: null,\n    };\n  }\n};\n\n/**\n * Decode an idl account of unknown type\n * @param accountInfo\n * @param idl\n * @returns\n */\nexport const decodeIdlAccountUnknown = <\n  T extends keyof AllAccountsMap<IDL>,\n  IDL extends Idl\n>(\n  accountInfo: AccountInfo<Buffer> | null,\n  idl: Idl\n): AccountInfo<Buffer> & ParsedIdlAccount<IDL>[T] => {\n  if (!accountInfo) throw \"No account found\";\n  // get idl accounts\n  const idlAccounts = idl[\"accounts\"];\n  if (!idlAccounts) throw \"No account definitions found in IDL\";\n  // find matching account name\n  const accountTypes = idlAccounts.map((a) => a.name);\n  const accountType = accountTypes?.find(\n    (accountType) =>\n      BorshAccountsCoder.accountDiscriminator(accountType).compare(\n        accountInfo.data.subarray(0, 8)\n      ) === 0\n  );\n  if (!accountType) throw \"No account discriminator match found\";\n\n  // decode\n  const parsed: TypeDef<\n    AllAccountsMap<IDL>[T],\n    IdlTypes<IDL>\n  > = new BorshAccountsCoder(idl).decode(accountType, accountInfo.data);\n  return {\n    ...accountInfo,\n    type: accountType as T,\n    parsed,\n  };\n};\n\n/**\n * Try to decode an account with idl types of unknown type\n * @param accountInfo\n * @param idl\n * @returns\n */\nexport const tryDecodeIdlAccountUnknown = <\n  T extends keyof AllAccountsMap<IDL>,\n  IDL extends Idl\n>(\n  accountInfo: AccountInfo<Buffer>,\n  idl: Idl\n): NullableIdlAccountInfo<T, IDL> => {\n  try {\n    return decodeIdlAccountUnknown<T, IDL>(accountInfo, idl);\n  } catch (e) {\n    return {\n      ...accountInfo,\n      type: \"unknown\",\n      parsed: null,\n    };\n  }\n};\n\n/**\n * Get program accounts of a specific idl type\n * @param connection\n * @param accountType\n * @param config\n * @param programId\n * @param idl\n * @returns\n */\nexport const getProgramIdlAccounts = async <\n  T extends keyof AllAccountsMap<IDL>,\n  IDL extends Idl\n>(\n  connection: Connection,\n  accountType: T,\n  programId: PublicKey,\n  idl: Idl,\n  config?: GetProgramAccountsConfig\n) => {\n  const accountInfos = await connection.getProgramAccounts(programId, {\n    filters: [\n      {\n        memcmp: {\n          offset: 0,\n          bytes: utils.bytes.bs58.encode(\n            BorshAccountsCoder.accountDiscriminator(accountType)\n          ),\n        },\n      },\n      ...(config?.filters ?? []),\n    ],\n  });\n  return accountInfos.map((accountInfo) => ({\n    pubkey: accountInfo.pubkey,\n    ...tryDecodeIdlAccount<T, IDL>(accountInfo.account, accountType, idl),\n  }));\n};\n\n/**\n * Fecthes multiple accounts in batches since there is a limit of\n * 100 accounts per connection.getMultipleAccountsInfo call\n * @param connection\n * @param ids\n * @param config\n * @param batchSize\n * @returns\n */\nexport const getBatchedMultipleAccounts = async (\n  connection: Connection,\n  ids: PublicKey[],\n  config?: GetMultipleAccountsConfig | Commitment,\n  batchSize = 100\n) => {\n  const batches: PublicKey[][] = [[]];\n  ids.forEach((id) => {\n    const batch = batches[batches.length - 1];\n    if (batch) {\n      if (batch.length >= batchSize) {\n        batches.push([id]);\n      } else {\n        batch.push(id);\n      }\n    }\n  });\n  const batchAccounts = await Promise.all(\n    batches.map((b) =>\n      b.length > 0 ? connection.getMultipleAccountsInfo(b, config) : []\n    )\n  );\n  return batchAccounts.flat();\n};\n"]}